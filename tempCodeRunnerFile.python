import os
import cv2
import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader
from torchvision import models, transforms
from skimage.feature import graycomatrix, graycoprops
from sklearn.metrics import classification_report, confusion_matrix
import matplotlib.pyplot as plt
import time

# ================= KONFIGURASI =================
DATASET_DIR = 'Dataset_Siap_Training' # Folder hasil split & augmentasi
BATCH_SIZE = 16
LEARNING_RATE = 0.001
EPOCHS = 20
NUM_CLASSES = 7
DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(f"ðŸš€ Menggunakan device: {DEVICE}")

# Mapping Label (Sesuai folder Anda)
CLASSES = ['0_Sehat', '1_Hitam', '2_Pecah', '3_Berjamur', 
           '4_Berlubang', '5_Coklat', '6_Muda']

# ================= 1. EKSTRAKSI FITUR GLCM =================
def extract_glcm_features(image):
    """
    Mengambil 5 fitur statistik dari GLCM:
    Contrast, Dissimilarity, Homogeneity, Energy, Correlation
    """
    # Convert ke Grayscale
    gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
    
    # Hitung GLCM (jarak 1, sudut 0, 45, 90, 135)
    glcm = graycomatrix(gray, distances=[1], angles=[0, np.pi/4, np.pi/2, 3*np.pi/4], 
                        levels=256, symmetric=True, normed=True)
    
    # Hitung properti (rata-rata dari 4 sudut)
    contrast = graycoprops(glcm, 'contrast').mean()
    dissimilarity = graycoprops(glcm, 'dissimilarity').mean()
    homogeneity = graycoprops(glcm, 'homogeneity').mean()
    energy = graycoprops(glcm, 'energy').mean()
    correlation = graycoprops(glcm, 'correlation').mean()
    
    # Kembalikan sebagai tensor float
    return torch.tensor([contrast, dissimilarity, homogeneity, energy, correlation], dtype=torch.float32)

# ================= 2. DATASET LOADER CUSTOM =================
class CoffeeFusionDataset(Dataset):
    def __init__(self, root_dir, split='train', transform=None):
        self.root_dir = os.path.join(root_dir, split)
        self.transform = transform
        self.data = []
        
        # Load semua path gambar
        for label_idx, class_name in enumerate(CLASSES):
            class_dir = os.path.join(self.root_dir, class_name)
            if not os.path.exists(class_dir):
                continue
            for img_name in os.listdir(class_dir):
                if img_name.lower().endswith(('.png', '.jpg', '.jpeg')):
                    self.data.append((os.path.join(class_dir, img_name), label_idx))

    def __len__(self):
        return len(self.data)

    def __getitem__(self, idx):
        img_path, label = self.data[idx]
        
        # Baca gambar (OpenCV baca sebagai BGR, convert ke RGB)
        img = cv2.imread(img_path)
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        
        # --- JALUR 1: GLCM (Manual Feature) ---
        # GLCM dihitung dari gambar asli (sebelum resize tensor) agar tekstur terjaga
        # Kita resize sedikit ke 224 agar beban komputasi GLCM tidak terlalu berat
        img_resized_cv = cv2.resize(img, (224, 224)) 
        glcm_features = extract_glcm_features(img_resized_cv)
        
        # --- JALUR 2: ShuffleNet (Visual Feature) ---
        if self.transform:
            img_tensor = self.transform(img) # Output sudah tensor
        
        return img_tensor, glcm_features, label

# Transformasi standar untuk Input CNN (ShuffleNet)
data_transforms = {
    'train': transforms.Compose([
        transforms.ToPILImage(),
        transforms.Resize((224, 224)),
        transforms.ToTensor(),
        transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
    ]),
    'test': transforms.Compose([
        transforms.ToPILImage(),
        transforms.Resize((224, 224)),
        transforms.ToTensor(),
        transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
    ]),
}

# ================= 3. ARSITEKTUR MODEL FUSI =================
class FusionShuffleNetGLCM(nn.Module):
    def __init__(self, num_classes):
        super(FusionShuffleNetGLCM, self).__init__()
        
        # --- Cabang 1: ShuffleNetV2 (Pre-trained) ---
        self.cnn = models.shufflenet_v2_x1_0(weights=models.ShuffleNet_V2_X1_0_Weights.DEFAULT)
        
        # Kita hapus layer klasifikasi bawaan (fc)
        # Output fitur ShuffleNet x1.0 adalah 1024 channel
        self.cnn.fc = nn.Identity() 
        
        # --- Cabang 2: GLCM Processing (Optional MLP) ---
        # Input 5 fitur GLCM -> dinormalisasi lewat Batch Norm
        self.glcm_fc = nn.Sequential(
            nn.BatchNorm1d(5), # Penting! Karena skala GLCM beda jauh dengan CNN
            nn.Linear(5, 16),
            nn.ReLU()
        )
        
        # --- Fusi & Klasifikasi Akhir ---
        # Input: 1024 (dari CNN) + 16 (dari GLCM) = 1040
        self.classifier = nn.Sequential(
            nn.Linear(1024 + 16, 512),
            nn.ReLU(),
            nn.Dropout(0.3),
            nn.Linear(512, num_classes) # Output 7 Kelas
        )

    def forward(self, image, glcm_data):
        # Proses Jalur Visual
        visual_feat = self.cnn(image) # Shape: [Batch, 1024]
        
        # Proses Jalur Tekstur
        texture_feat = self.glcm_fc(glcm_data) # Shape: [Batch, 16]
        
        # Gabungkan (Concatenate)
        combined_feat = torch.cat((visual_feat, texture_feat), dim=1)
        
        # Klasifikasi
        output = self.classifier(combined_feat)
        return output

# ================= 4. TRAINING & EVALUATION =================
def train_model():
    # Load Data
    train_dataset = CoffeeFusionDataset(DATASET_DIR, 'train', data_transforms['train'])
    test_dataset = CoffeeFusionDataset(DATASET_DIR, 'test', data_transforms['test'])
    
    train_loader = DataLoader(train_dataset, batch_size=BATCH_SIZE, shuffle=True)
    test_loader = DataLoader(test_dataset, batch_size=BATCH_SIZE, shuffle=False)
    
    print(f"ðŸ“Š Data Train: {len(train_dataset)} | Data Test: {len(test_dataset)}")
    
    # Init Model
    model = FusionShuffleNetGLCM(num_classes=NUM_CLASSES).to(DEVICE)
    criterion = nn.CrossEntropyLoss()
    optimizer = optim.Adam(model.parameters(), lr=LEARNING_RATE)
    
    # Loop Epoch
    for epoch in range(EPOCHS):
        print(f"\nEpoch {epoch+1}/{EPOCHS}")
        print("-" * 10)
        
        # --- TRAINING PHASE ---
        model.train()
        running_loss = 0.0
        correct = 0
        total = 0
        
        for images, glcm_feats, labels in train_loader:
            images, glcm_feats, labels = images.to(DEVICE), glcm_feats.to(DEVICE), labels.to(DEVICE)
            
            optimizer.zero_grad()
            outputs = model(images, glcm_feats) # Masuk ke model fusi
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()
            
            running_loss += loss.item()
            _, predicted = torch.max(outputs.data, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()
            
        epoch_acc = 100 * correct / total
        print(f"Train Loss: {running_loss/len(train_loader):.4f} | Acc: {epoch_acc:.2f}%")
        
        # --- TESTING PHASE ---
        model.eval()
        correct_test = 0
        total_test = 0
        all_preds = []
        all_labels = []
        
        with torch.no_grad():
            for images, glcm_feats, labels in test_loader:
                images, glcm_feats, labels = images.to(DEVICE), glcm_feats.to(DEVICE), labels.to(DEVICE)
                outputs = model(images, glcm_feats)
                _, predicted = torch.max(outputs.data, 1)
                
                total_test += labels.size(0)
                correct_test += (predicted == labels).sum().item()
                
                all_preds.extend(predicted.cpu().numpy())
                all_labels.extend(labels.cpu().numpy())
        
        test_acc = 100 * correct_test / total_test
        print(f"Test Acc : {test_acc:.2f}%")

    # --- FINAL EVALUATION ---
    print("\nâœ… Training Selesai. Laporan Evaluasi Akhir:")
    print(classification_report(all_labels, all_preds, target_names=CLASSES))
    
    # Simpan Model
    torch.save(model.state_dict(), 'model_skripsi_fusi.pth')
    print("ðŸ’¾ Model disimpan sebagai 'model_skripsi_fusi.pth'")

if __name__ == '__main__':
    train_model()
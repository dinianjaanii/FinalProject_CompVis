import os
import cv2
import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader
from torchvision import models, transforms
from skimage.feature import graycomatrix, graycoprops
from sklearn.metrics import classification_report
import matplotlib.pyplot as plt
import time

# ================= KONFIGURASI =================
DATASET_ROOT = 'dataset/train_preprocessing' # Folder hasil script 04 baru

BATCH_SIZE = 16
LEARNING_RATE = 0.0001
EPOCHS = 30
NUM_CLASSES = 6
DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu")

print(f"üöÄ Menggunakan device: {DEVICE}")

# ================= 1. EKSTRAKSI FITUR GLCM =================
def extract_glcm_features(image_gray):
    # Hitung GLCM (jarak 1, sudut 0, 45, 90, 135)
    glcm = graycomatrix(image_gray, distances=[1], angles=[0, np.pi/4, np.pi/2, 3*np.pi/4], 
                        levels=256, symmetric=True, normed=True)
    
    contrast = graycoprops(glcm, 'contrast').mean()
    dissimilarity = graycoprops(glcm, 'dissimilarity').mean()
    homogeneity = graycoprops(glcm, 'homogeneity').mean()
    energy = graycoprops(glcm, 'energy').mean()
    correlation = graycoprops(glcm, 'correlation').mean()
    
    return torch.tensor([contrast, dissimilarity, homogeneity, energy, correlation], dtype=torch.float32)

# ================= 2. DATASET LOADER (DISESUAIKAN STRUKTUR BARU) =================
class FusionDataset(Dataset):
    def __init__(self, root_dir, split='train', transform=None):
        # root_dir/train
        self.split_dir = os.path.join(root_dir, split)
        self.transform = transform
        self.data = []
        
        # Cek folder split
        if not os.path.exists(self.split_dir):
            print(f"‚ùå Error: Folder '{self.split_dir}' tidak ditemukan!")
            return

        # Ambil daftar kelas (0_Sehat, 1_Hitam, dst)
        self.classes = sorted([d for d in os.listdir(self.split_dir) if os.path.isdir(os.path.join(self.split_dir, d))])
        
        print(f"üìÇ Memuat data '{split}'...")
        
        for label_idx, class_name in enumerate(self.classes):
            # Masuk ke folder kelas: Dataset_Siap_Model/train/0_Sehat
            class_path = os.path.join(self.split_dir, class_name)
            
            # Tentukan sub-folder RGB dan GLCM
            rgb_folder = os.path.join(class_path, 'ShuffleNet_RGB')
            gray_folder = os.path.join(class_path, 'GLCM_Grayscale')
            
            if not os.path.exists(rgb_folder) or not os.path.exists(gray_folder):
                print(f"   ‚ö†Ô∏è Skip kelas '{class_name}': Sub-folder tidak lengkap.")
                continue
            
            # Ambil file dari folder RGB
            files = os.listdir(rgb_folder)
            count = 0
            for f in files:
                # Pastikan file gambar valid
                if not f.lower().endswith(('.png', '.jpg', '.jpeg')): continue

                path_img_rgb = os.path.join(rgb_folder, f)
                path_img_gray = os.path.join(gray_folder, f)
                
                # Validasi: File pasangannya di folder Gray harus ada
                if os.path.exists(path_img_gray):
                    self.data.append((path_img_rgb, path_img_gray, label_idx))
                    count += 1
            
            print(f"   - Kelas {class_name}: {count} gambar")

    def __len__(self):
        return len(self.data)

    def __getitem__(self, idx):
        path_rgb, path_gray, label = self.data[idx]
        
        # Baca Gambar
        img_rgb = cv2.imread(path_rgb)
        img_rgb = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2RGB)
        img_gray = cv2.imread(path_gray, cv2.IMREAD_GRAYSCALE)
        
        # Jalur 1: ShuffleNet
        if self.transform:
            visual_input = self.transform(img_rgb)
            
        # Jalur 2: GLCM
        texture_input = extract_glcm_features(img_gray)
        
        return visual_input, texture_input, label

# Transformasi Standar
data_transforms = transforms.Compose([
    transforms.ToPILImage(),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
])

# ================= 3. ARSITEKTUR MODEL FUSI =================
class FusionModel(nn.Module):
    def __init__(self, num_classes):
        super(FusionModel, self).__init__()
        
        # Visual Branch (ShuffleNet)
        self.cnn = models.shufflenet_v2_x1_0(weights='DEFAULT')
        self.cnn.fc = nn.Identity() 
        
        # Texture Branch (GLCM MLP)
        self.glcm_mlp = nn.Sequential(
            nn.BatchNorm1d(5),
            nn.Linear(5, 32),
            nn.ReLU()
        )
        
        # Fusion & Classification
        self.classifier = nn.Sequential(
            nn.Linear(1024 + 32, 512),
            nn.ReLU(),
            nn.Dropout(0.3),
            nn.Linear(512, num_classes)
        )

    def forward(self, x_visual, x_texture):
        feat_visual = self.cnn(x_visual)
        feat_texture = self.glcm_mlp(x_texture)
        feat_fusion = torch.cat((feat_visual, feat_texture), dim=1)
        return self.classifier(feat_fusion)

# ================= 4. TRAINING LOOP =================
def train_model():
    # Cek dataset
    if not os.path.exists(DATASET_ROOT):
        print(f"‚ùå Error: Folder '{DATASET_ROOT}' tidak ditemukan. Jalankan script 04 dulu!")
        return

    train_ds = FusionDataset(DATASET_ROOT, 'train', data_transforms)
    test_ds = FusionDataset(DATASET_ROOT, 'test', data_transforms)
    
    train_loader = DataLoader(train_ds, batch_size=BATCH_SIZE, shuffle=True)
    test_loader = DataLoader(test_ds, batch_size=BATCH_SIZE, shuffle=False)
    
    if len(train_ds) == 0:
        print("‚ùå Dataset kosong! Cek kembali proses pre-processing.")
        return

    model = FusionModel(num_classes=NUM_CLASSES).to(DEVICE)
    criterion = nn.CrossEntropyLoss()
    optimizer = optim.Adam(model.parameters(), lr=LEARNING_RATE)
    
    history = {'train_loss': [], 'train_acc': [], 'test_acc': []}
    
    print(f"\nüöÄ Mulai Training ({EPOCHS} Epochs)...")
    start_time = time.time()
    
    for epoch in range(EPOCHS):
        model.train()
        running_loss = 0.0
        correct = 0
        total = 0
        
        for visuals, textures, labels in train_loader:
            visuals, textures, labels = visuals.to(DEVICE), textures.to(DEVICE), labels.to(DEVICE)
            
            optimizer.zero_grad()
            outputs = model(visuals, textures)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()
            
            running_loss += loss.item()
            _, preds = torch.max(outputs, 1)
            total += labels.size(0)
            correct += (preds == labels).sum().item()
            
        epoch_loss = running_loss / len(train_loader)
        epoch_acc = 100 * correct / total
        
        # Evaluasi Test
        model.eval()
        correct_test = 0
        total_test = 0
        with torch.no_grad():
            for visuals, textures, labels in test_loader:
                visuals, textures, labels = visuals.to(DEVICE), textures.to(DEVICE), labels.to(DEVICE)
                outputs = model(visuals, textures)
                _, preds = torch.max(outputs, 1)
                total_test += labels.size(0)
                correct_test += (preds == labels).sum().item()
        test_acc = 100 * correct_test / total_test
        
        history['train_loss'].append(epoch_loss)
        history['train_acc'].append(epoch_acc)
        history['test_acc'].append(test_acc)
        
        print(f"Epoch {epoch+1}/{EPOCHS} | Loss: {epoch_loss:.4f} | Train Acc: {epoch_acc:.1f}% | Test Acc: {test_acc:.1f}%")

    print(f"\n‚úÖ Selesai dalam {(time.time()-start_time)/60:.1f} menit.")
    torch.save(model.state_dict(), 'model_fusi_kopi_final.pth')
    
    # Plot Grafik
    plt.figure(figsize=(10, 4))
    plt.subplot(1, 2, 1)
    plt.plot(history['train_acc'], label='Train')
    plt.plot(history['test_acc'], label='Test')
    plt.title('Akurasi')
    plt.legend()
    plt.subplot(1, 2, 2)
    plt.plot(history['train_loss'], color='orange')
    plt.title('Loss')
    plt.savefig('grafik_training.png')
    print("üìä Grafik disimpan: grafik_training.png")

    # Classification Report
    model.eval()
    all_preds = []
    all_labels = []
    with torch.no_grad():
        for visuals, textures, labels in test_loader:
            visuals, textures = visuals.to(DEVICE), textures.to(DEVICE)
            outputs = model(visuals, textures)
            _, preds = torch.max(outputs, 1)
            all_preds.extend(preds.cpu().numpy())
            all_labels.extend(labels.cpu().numpy())
            
    print("\n--- LAPORAN AKHIR ---")
    print(classification_report(all_labels, all_preds, target_names=train_ds.classes))

if __name__ == '__main__':
    train_model()